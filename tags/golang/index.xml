<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on 大王派我来搬砖</title>
    <link>http://gopherday.com/tags/golang/</link>
    <description>Recent content in Golang on 大王派我来搬砖</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>tx991020@gmail.com (andy wu)</managingEditor>
    <webMaster>tx991020@gmail.com (andy wu)</webMaster>
    <lastBuildDate>Mon, 27 Nov 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://gopherday.com/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>golang nsq</title>
      <link>http://gopherday.com/post/2017-11-27-go-nsq/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      <author>tx991020@gmail.com (andy wu)</author>
      <guid>http://gopherday.com/post/2017-11-27-go-nsq/</guid>
      <description>安装 brew install nsq nsqd ： 负责接收消息，存储队列和将消息发送给客户端，nsqd 可以多机器部署，当你使用客户端向一个topic发送消息时，可以配置多个nsqd地址，消息会随机的 分配到各个nsqd上，nsqd优先把消息存储到内存channel中，当内存channel满了之后，则把消息写到磁盘文件中。他监听了两个tcp端口，一个用来服务客 户端，一个用来提供http的接口 ，nsqd 启动时置顶下nsqlookupd地址即可： 在一个 shell 中，运行 nsqlookupd:
nsqlookupd： 主要负责服务发现 负责nsqd的心跳、状态监测，给客户端、nsqadmin提供nsqd地址与状态
➜nsqlookupd [nsqlookupd] 2017/11/27 22:48:11.186029 nsqlookupd v1.0.0-compat (built w/go1.8) [nsqlookupd] 2017/11/27 22:48:11.186266 TCP: listening on [::]:4160 [nsqlookupd] 2017/11/27 22:48:11.186314 HTTP: listening on [::]:4161 再开启一个 shell，运行 nsqd:
➜ bin ./nsqd --lookupd-tcp-address=127.0.0.1:4160 [nsqd] 2017/11/27 22:49:11.433686 nsqd v1.0.0-compat (built w/go1.8) [nsqd] 2017/11/27 22:49:11.433755 ID: 280 [nsqd] 2017/11/27 22:49:11.433797 NSQ: persisting topic/channel metadata to nsqd.dat [nsqd] 2017/11/27 22:49:11.</description>
    </item>
    
    <item>
      <title>go-colly</title>
      <link>http://gopherday.com/post/2017-10-18-go-colly/</link>
      <pubDate>Mon, 20 Mar 2017 00:00:00 +0000</pubDate>
      <author>tx991020@gmail.com (andy wu)</author>
      <guid>http://gopherday.com/post/2017-10-18-go-colly/</guid>
      <description>package main import ( &amp;#34;fmt&amp;#34; ) type Collector struct { // UserAgent is the User-Agent string used by HTTP requests 	UserAgent string // MaxDepth limits the recursion depth of visited URLs. 	// Set it to 0 for infinite recursion (default). 	MaxDepth int } func UserAgent(ua string) func(*Collector) { return func(c *Collector) { c.UserAgent = ua } } func (c *Collector) Init() { c.UserAgent = &amp;#34;colly - https://github.com/gocolly/colly&amp;#34; c.</description>
    </item>
    
    <item>
      <title>golang jsonrpc</title>
      <link>http://gopherday.com/post/2017-03-14-jsonrpc/</link>
      <pubDate>Tue, 14 Mar 2017 00:00:00 +0000</pubDate>
      <author>tx991020@gmail.com (andy wu)</author>
      <guid>http://gopherday.com/post/2017-03-14-jsonrpc/</guid>
      <description>client package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/rpc/jsonrpc&amp;#34; &amp;#34;time&amp;#34; ) type Args struct { A, B int } type Arith int func main() { // Create a new jsonrpc client 	// 	// NewClient returns a new rpc.Client to handle requests to the 	// set of services at the other end of the connection. 	// 	// Client will use json as the server&amp;#39;s specified codec 	// to encode requests and decode responses.</description>
    </item>
    
    <item>
      <title>golang net/rpc</title>
      <link>http://gopherday.com/post/2017-03-13-rpc/</link>
      <pubDate>Mon, 13 Mar 2017 00:00:00 +0000</pubDate>
      <author>tx991020@gmail.com (andy wu)</author>
      <guid>http://gopherday.com/post/2017-03-13-rpc/</guid>
      <description>client package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/rpc&amp;#34; ) type Args struct { A, B int } type Quotient struct { Quo, Rem int } func main() { client, err := rpc.DialHTTP(&amp;#34;tcp&amp;#34;, &amp;#34;127.0.0.1:1234&amp;#34;) if err != nil { log.Fatal(&amp;#34;dialing:&amp;#34;, err) } // Synchronous call 	args := &amp;amp;Args{7, 8} var reply int err = client.Call(&amp;#34;Arith.Multiply&amp;#34;, args, &amp;amp;reply) if err != nil { log.Fatal(&amp;#34;arith error:&amp;#34;, err) } fmt.Printf(&amp;#34;Arith: %d*%d=%d\n&amp;#34;, args.A, args.</description>
    </item>
    
    <item>
      <title>golang set</title>
      <link>http://gopherday.com/post/2016-11-20-golang-set/</link>
      <pubDate>Sun, 20 Nov 2016 00:00:00 +0000</pubDate>
      <author>tx991020@gmail.com (andy wu)</author>
      <guid>http://gopherday.com/post/2016-11-20-golang-set/</guid>
      <description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; ) type Set struct { m map[int]bool sync.RWMutex } func New() *Set { return &amp;amp;Set{ m: map[int]bool{}, } } func (s *Set) Add(item int) { s.Lock() defer s.Unlock() s.m[item] = true } func (s *Set) Remove(item int) { s.Lock() s.Unlock() delete(s.m, item) } func (s *Set) Has(item int) bool { s.RLock() defer s.RUnlock() _, ok := s.m[item] return ok } func (s *Set) Len() int { return len(s.</description>
    </item>
    
    <item>
      <title>Gin&#43;Mysql简单的Restful风格的API</title>
      <link>http://gopherday.com/post/2016-11-12-gin&#43;mysql-api/</link>
      <pubDate>Sat, 12 Nov 2016 00:00:00 +0000</pubDate>
      <author>tx991020@gmail.com (andy wu)</author>
      <guid>http://gopherday.com/post/2016-11-12-gin&#43;mysql-api/</guid>
      <description>数据库 CREATE TABLE `person` ( `id` int(11) NOT NULL AUTO_INCREMENT, `first_name` varchar(40) NOT NULL DEFAULT &amp;#39;&amp;#39;, `last_name` varchar(40) NOT NULL DEFAULT &amp;#39;&amp;#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 组织项目 在项目根目录创建下面三个文件夹，apis，databases和models，并在文件夹内创建文件。此时我们的目录结果如下： myql.go的包代码如下： package database import ( &amp;#34;database/sql&amp;#34; _ &amp;#34;github.com/go-sql-driver/mysql&amp;#34; &amp;#34;log&amp;#34; ) var SqlDB *sql.DB func init() { var err error SqlDB, err = sql.Open(&amp;#34;mysql&amp;#34;, &amp;#34;root:@tcp(127.0.0.1:3306)/test?parseTime=true&amp;#34;) if err != nil { log.Fatal(err.Error()) } err = SqlDB.Ping() if err != nil { log.</description>
    </item>
    
    <item>
      <title>ElasticSearch 入门</title>
      <link>http://gopherday.com/post/2016-10-15-elasticsearch01/</link>
      <pubDate>Sat, 15 Oct 2016 00:00:00 +0000</pubDate>
      <author>tx991020@gmail.com (andy wu)</author>
      <guid>http://gopherday.com/post/2016-10-15-elasticsearch01/</guid>
      <description></description>
    </item>
    
    <item>
      <title>golang heap interface实现</title>
      <link>http://gopherday.com/post/2016-09-15-go-heap/</link>
      <pubDate>Thu, 15 Sep 2016 00:00:00 +0000</pubDate>
      <author>tx991020@gmail.com (andy wu)</author>
      <guid>http://gopherday.com/post/2016-09-15-go-heap/</guid>
      <description>package main import ( &amp;#34;container/heap&amp;#34; &amp;#34;fmt&amp;#34; ) // An IntHeap is a min-heap of ints. type IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h IntHeap) Less(i, j int) bool { return h[i] &amp;lt; h[j] } // The following two IntHeap methods Push and Pop use pointer receivers // because they modify the slice&amp;#39;s length, not just its contents.</description>
    </item>
    
    <item>
      <title>golang sync.map</title>
      <link>http://gopherday.com/post/2017-04-10-go-sync.map/</link>
      <pubDate>Sun, 10 Apr 2016 00:00:00 +0000</pubDate>
      <author>tx991020@gmail.com (andy wu)</author>
      <guid>http://gopherday.com/post/2017-04-10-go-sync.map/</guid>
      <description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; ) func main() { list := map[string]interface{}{ &amp;#34;name&amp;#34;: &amp;#34;田馥甄&amp;#34;, &amp;#34;birthday&amp;#34;: &amp;#34;1983年3月30日&amp;#34;, &amp;#34;age&amp;#34;: 34, &amp;#34;hobby&amp;#34;: []string{&amp;#34;听音乐&amp;#34;, &amp;#34;看电影&amp;#34;, &amp;#34;电视&amp;#34;, &amp;#34;和姐妹一起讨论私人话题&amp;#34;}, &amp;#34;constellation&amp;#34;: &amp;#34;白羊座&amp;#34;, } var m sync.Map for k, v := range list { m.Store(k, v) } var wg sync.WaitGroup wg.Add(2) go func() { m.Store(&amp;#34;age&amp;#34;, 22) m.LoadOrStore(&amp;#34;tag&amp;#34;, 8888) wg.Done() }() go func() { m.Delete(&amp;#34;constellation&amp;#34;) m.Store(&amp;#34;age&amp;#34;, 18) wg.Done() }() wg.Wait() m.Range(func(key, value interface{}) bool { fmt.Println(key, value) return true }) } </description>
    </item>
    
    <item>
      <title>golang redispool</title>
      <link>http://gopherday.com/post/2016-02-15-golang-redispool/</link>
      <pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate>
      <author>tx991020@gmail.com (andy wu)</author>
      <guid>http://gopherday.com/post/2016-02-15-golang-redispool/</guid>
      <description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/garyburd/redigo/redis&amp;#34; ) var pool *redis.Pool func init() { pool = &amp;amp;redis.Pool{ MaxIdle: 16, MaxActive: 0, IdleTimeout: 300, Dial: func() (redis.Conn, error) { return redis.Dial(&amp;#34;tcp&amp;#34;, &amp;#34;localhost:6379&amp;#34;) }, } } func main() { c := pool.Get() defer c.Close() _, err := c.Do(&amp;#34;Set&amp;#34;, &amp;#34;abc&amp;#34;, 100) if err != nil { fmt.Println(err) return } r, err := redis.Int(c.Do(&amp;#34;Get&amp;#34;, &amp;#34;abc&amp;#34;)) if err != nil { fmt.Println(&amp;#34;get abc failed,&amp;#34;, err) return } fmt.</description>
    </item>
    
  </channel>
</rss>